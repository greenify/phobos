Ddoc

$(COMMENT Pending changelog for 2.072. This will get copied to dlang.org and
    cleared when master gets merged into stable prior to 2.072.
)

$(BUGSTITLE Library Changes,
    $(LI $(RELATIVE_LINK2 process, Process creation in `std.process` was sped up
        on Posix.))
    $(LI $(RELATIVE_LINK2 std-algorithm-iteration-cumulativeFold, $(XREF
        algorithm.iterator, cumulativeFold) was added.))
    $(LI $(RELATIVE_LINK2 padLeft-padRight, `std.range.padLeft` and
        `std.range.padRight` were added.))
    $(LI $(RELATIVE_LINK2 regex-multiple-patterns, `std.regex.regex` now
        supports matching multiple patterns in one go.))
    $(LI $(RELATIVE_LINK2 mutation, `std.algorithm.mutation` was exposed))
    $(LI $(RELATIVE_LINK2 iota-length-size_t, `std.range.iota's `.length`
        property is fixed to `size_t` instead of the type being iterated))
    $(LI $(XREF uni, isNumber) and $(XREF uni, isPunctuation) now use a separate,
    optimized path for ASCII inputs.)
    $(LI $(XREF uni, isAlphaNum), which is analogous to $(XREF ascii, isAlphaNum)
        was added.)
    $(LI $(XREF regex, regex) now supports inline comments with (?#...) syntax.)
    $(LI std.regex had numerous optimization applied, compile-time $(XREF regex, ctRegex)
    should now be generally faster then the run-time version.)
    $(LI $(REF moveAt, std,range,primitives) accepts only `size_t` for its index
    arguments.)
    $(LI $(REF isStrictlyMonotonic, std,algorithm,sorting) which doesn't allow
    equal values was added.)
    $(LI $(REF readLink, std,file) and $(REF symlink, std,file) have been
        rangified.)
    $(LI All overloads of `std.conv.toImpl` has been made private. Please use
        $(XREF conv, to) instead.)
    $(LI $(RELATIVE_LINK2 min-max-element,
    `std.algorithm.searching.{min,max}Element` for ranges have been added.))
)

$(BUGSTITLE Library Changes,

$(LI $(LNAME2 process, Process creation in `std.process` was sped up on Posix.)
    $(P Previously, Posix systems would attempt to close every file descriptor
        from 3 to the maximum file descriptor number if `inheritFDs` was not
        specified with `spawnProcess`, `pipeProcess`, etc.
        $(STDMODREF process, std.process) now uses `poll()` to determine which
        descriptors need closing.
    )
)

$(LI $(LNAME2 std-algorithm-iteration-cumulativeFold, $(XREF algorithm.iteration,
cumulativeFold) was added.)

    $(P $(XREF algorithm.iterator, cumulativeFold) returns the successive
        reduced values of an input range.)
------
assert([1, 2, 3, 4, 5].cumulativeFold!((a, b) => a + b).array == [1, 3, 6, 10, 15]);
assert([1, 2, 3].cumulativeFold!((a, b) => a + b)(100).array == [101, 103, 106]);
------
)

$(LI $(LNAME2 padLeft-padRight, `std.range.padLeft` and `std.range.padRight`
        were added.)
    $(P $(XREF range, padLeft) and $(XREF range, padRight) are functions for
        padding ranges to a specified length using the given element.
    )

-------
import std.range;
import std.algorithm.comparison;

assert([1, 2, 3, 4, 5].padLeft(0, 7).equal([0, 0, 1, 2, 3, 4, 5]));

assert("Hello World!".padRight('!', 15).equal("Hello World!!!!"));
-------
)

$(LI $(LNAME2 regex-multiple-patterns, `std.regex.regex` now supports matching multiple patterns in one go.)
-------
import std.regex;
// multi-pattern regex
auto multi = regex([`\d+,\d+`,`(a-z]+):(\d+)`]);
auto m = "abc:43 12,34".matchAll(multi);
assert(m.front.whichPattern == 2);
assert(m.front[1] == "abc");
assert(m.front[2] == "43");
m.popFront();
assert(m.front.whichPattern == 1);
assert(m.front[1] == "12");
-------
)

$(LI $(LNAME2 mutation, `std.algorithm.mutation` was exposed)
    $(P $(REF swapAt, std,algorithm,mutation) allows to swap elements
        of a RandomAccessRange by their indices.
    )
)

$(LI $(LNAME2 iota-length-size_t, `std.range.iota's `.length` property is fixed
        to `size_t` instead of the type being iterated)
    $(P $(XREF range, iota)'s `.length` property is now always returned as
        `size_t`.  This means if you are on a 32-bit CPU and you are using
        iota to iterate 64-bit types, the length will be truncated to `size_t`.
        In non-release mode, you will get an exception if the length exceeds
        `size_t.max` in your call to `iota`.
    )
)

$(LI $(LNAME2 min-max-element, `std.algorithm.searching.{min,max}Element`
	have been added.)
    $(P $(XREF algorithm, searching, minElement) and $(XREF algorithm,
    searching, maxElement) are functions to search for the minimum and maximum
    element in a range. They support a custom `map` accessor.
    )

-------
import std.algorithm.searching;
import std.range;
import std.typecons;
assert([3, 1, 4].minElement == 1);
assert([4, 7, 5].enumerate.maxElement!`a.value` == tuple(1, 7));
-------
)

)

Macros:
    TITLE=Change Log

    BUGSTITLE = <div class="bugsfixed">$(H4 $1) $(OL $2 )</div>

    RELATIVE_LINK2=<a href="#$1">$+</a>
    LNAME2=<a class="anchor" title="Permalink to this section" id="$1" href="#$1">$+</a>

    STDMODREF = <a href="phobos/std_$1.html">$2</a>
    XREF = <a href="phobos/std_$1.html#$2">$2</a>
    CXREF = <a href="phobos/core_$1.html#$2">$2</a>
    OXREF = <a href="phobos/object.html#$2">$2</a>
    NXREF = <a href="phobos/std_$1.html#.$2">$2</a>
    NCXREF = <a href="phobos/core_$1.html#.$2">$2</a>
    NOXREF = <a href="phobos/object.html#.$2">$2</a>

    BOOKTABLE = <table><caption>$1</caption>$+</table>
